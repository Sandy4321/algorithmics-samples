
# coding: utf-8

# # The Fibonacci number

# The Fibonacci numbers 0,1,1,2,3,5,8,13,21,34,… are generated by the following simple rule:  
# * Fn=0, n=0  
# * Fn=1, n=1  
# * Fn= Fn−1 + Fn−2, n>1  
# 

# ### Recursive solution

# A recursive solution to the Fibonacci number is as follows.

# In[9]:

def fibonacci(n):
    if (n==0):
        return 0
    if (n==1):
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)


# However `T(n)` is exponential in `n`, which implies that the algorithm is impractically slow except for very small values of `n`.

# ### Dynamic programming solution

# Notice that many computations are repeated in the previous solution. A more sensible scheme would store the intermediate results—the values `F0,F1,…,Fn−1` as soon as they become known. This is a case of **dynamic programming**, with `T(n)` linear in `n`.

# In[10]:

def fibonacci2(n):
    if (n==0):
        return 0
    else :
        f = [0,1]
        for i in range(2,n+1):
            f.append( f[i-1] + f[i-2] )
        return f[n]


# Let's check computation times.

# In[ ]:

get_ipython().magic(u'timeit fibonacci2(50)')


# In[ ]:

get_ipython().magic(u'timeit fibonacci(50)')


# In[ ]:



